<!DOCTYPE html>
<html lang="en"><head>
<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/tabby.min.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/light-border.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-html.min.css" rel="stylesheet" data-mode="light">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.3.450">

  <meta name="author" content="Dillon Murphy, Cal Poly - San Luis Obispo, CA">
  <title>Overview of the youdrawitR Package</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="index_files/libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="index_files/libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="index_files/libs/revealjs/dist/theme/quarto.css">
  <link href="index_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="index_files/libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="index_files/libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="index_files/libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">

  .callout {
    margin-top: 1em;
    margin-bottom: 1em;  
    border-radius: .25rem;
  }

  .callout.callout-style-simple { 
    padding: 0em 0.5em;
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
    display: flex;
  }

  .callout.callout-style-default {
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
  }

  .callout .callout-body-container {
    flex-grow: 1;
  }

  .callout.callout-style-simple .callout-body {
    font-size: 1rem;
    font-weight: 400;
  }

  .callout.callout-style-default .callout-body {
    font-size: 0.9rem;
    font-weight: 400;
  }

  .callout.callout-titled.callout-style-simple .callout-body {
    margin-top: 0.2em;
  }

  .callout:not(.callout-titled) .callout-body {
      display: flex;
  }

  .callout:not(.no-icon).callout-titled.callout-style-simple .callout-content {
    padding-left: 1.6em;
  }

  .callout.callout-titled .callout-header {
    padding-top: 0.2em;
    margin-bottom: -0.2em;
  }

  .callout.callout-titled .callout-title  p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
  }
    
  .callout.callout-titled.callout-style-simple .callout-content  p {
    margin-top: 0;
  }

  .callout.callout-titled.callout-style-default .callout-content  p {
    margin-top: 0.7em;
  }

  .callout.callout-style-simple div.callout-title {
    border-bottom: none;
    font-size: .9rem;
    font-weight: 600;
    opacity: 75%;
  }

  .callout.callout-style-default  div.callout-title {
    border-bottom: none;
    font-weight: 600;
    opacity: 85%;
    font-size: 0.9rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-default div.callout-content {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-simple .callout-icon::before {
    height: 1rem;
    width: 1rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 1rem 1rem;
  }

  .callout.callout-style-default .callout-icon::before {
    height: 0.9rem;
    width: 0.9rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 0.9rem 0.9rem;
  }

  .callout-title {
    display: flex
  }
    
  .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  .callout.no-icon::before {
    display: none !important;
  }

  .callout.callout-titled .callout-body > .callout-content > :last-child {
    margin-bottom: 0.5rem;
  }

  .callout.callout-titled .callout-icon::before {
    margin-top: .5rem;
    padding-right: .5rem;
  }

  .callout:not(.callout-titled) .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  /* Callout Types */

  div.callout-note {
    border-left-color: #4582ec !important;
  }

  div.callout-note .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEU0lEQVRYCcVXTWhcVRQ+586kSUMMxkyaElstCto2SIhitS5Ek8xUKV2poatCcVHtUlFQk8mbaaziwpWgglJwVaquitBOfhQXFlqlzSJpFSpIYyXNjBNiTCck7x2/8/LeNDOZxDuEkgOXe++553zfefee+/OYLOXFk3+1LLrRdiO81yNqZ6K9cG0P3MeFaMIQjXssE8Z1JzLO9ls20MBZX7oG8w9GxB0goaPrW5aNMp1yOZIa7Wv6o2ykpLtmAPs/vrG14Z+6d4jpbSKuhdcSyq9wGMPXjonwmESXrriLzFGOdDBLB8Y6MNYBu0dRokSygMA/mrun8MGFN3behm6VVAwg4WR3i6FvYK1T7MHo9BK7ydH+1uurECoouk5MPRyVSBrBHMYwVobG2aOXM07sWrn5qgB60rc6mcwIDJtQrnrEr44kmy+UO9r0u9O5/YbkS9juQckLed3DyW2XV/qWBBB3ptvI8EUY3I9p/67OW+g967TNr3Sotn3IuVlfMLVnsBwH4fsnebJvyGm5GeIUA3jljERmrv49SizPYuq+z7c2H/jlGC+Ghhupn/hcapqmcudB9jwJ/3jvnvu6vu5lVzF1fXyZuZZ7U8nRmVzytvT+H3kilYvH09mLWrQdwFSsFEsxFVs5fK7A0g8gMZjbif4ACpKbjv7gNGaD8bUrlk8x+KRflttr22JEMRUbTUwwDQScyzPgedQHZT0xnx7ujw2jfVfExwYHwOsDTjLdJ2ebmeQIlJ7neo41s/DrsL3kl+W2lWvAga0tR3zueGr6GL78M3ifH0rGXrBC2aAR8uYcIA5gwV8zIE8onoh8u0Fca/ciF7j1uOzEnqcIm59sEXoGc0+z6+H45V1CvAvHcD7THztu669cnp+L0okAeIc6zjbM/24LgGM1gZk7jnRu1aQWoU9sfUOuhrmtaPIO3YY1KLLWZaEO5TKUbMY5zx8W9UJ6elpLwKXbsaZ4EFl7B4bMtDv0iRipKoDQT2sNQI9b1utXFdYisi+wzZ/ri/1m7QfDgEuvgUUEIJPq3DhX/5DWNqIXDOweC2wvIR90Oq3lDpdMIgD2r0dXvGdsEW5H6x6HLRJYU7C69VefO1x8Gde1ZFSJLfWS1jbCnhtOPxmpfv2LXOA2Xk2tvnwKKPFuZ/oRmwBwqRQDcKNeVQkYcOjtWVBuM/JuYw5b6isojIkYxyYAFn5K7ZBF10fea52y8QltAg6jnMqNHFBmGkQ1j+U43HMi2xMar1Nv0zGsf1s8nUsmUtPOOrbFIR8bHFDMB5zL13Gmr/kGlCkUzedTzzmzsaJXhYawnA3UmARpiYj5ooJZiUoxFRtK3X6pgNPv+IZVPcnwbOl6f+aBaO1CNvPW9n9LmCp01nuSaTRF2YxHqZ8DYQT6WsXT+RD6eUztwYLZ8rM+rcPxamv1VQzFUkzFXvkiVrySGQgJNvXHJAxiU3/NwiC03rSf05VBaPtu/Z7/B8Yn/w7eguloAAAAAElFTkSuQmCC');
  }

  div.callout-note.callout-style-default .callout-title {
    background-color: #dae6fb
  }

  div.callout-important {
    border-left-color: #d9534f !important;
  }

  div.callout-important .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEKklEQVRYCcVXTWhcVRS+575MJym48A+hSRFr00ySRQhURRfd2HYjk2SSTokuBCkU2o0LoSKKraKIBTcuFCoidGFD08nkBzdREbpQ1EDNIv8qSGMFUboImMSZd4/f9zJv8ibJMC8xJQfO3HPPPef7zrvvvnvviIkpC9nsw0UttFunbUhpFzFtarSd6WJkStVMw5xyVqYTvkwfzuf/5FgtkVoB0729j1rjXwThS7Vio+Mo6DNnvLfahoZ+i/o32lULuJ3NNiz7q6+pyAUkJaFF6JwaM2lUJlV0MlnQn5aTRbEu0SEqHUa0A4AdiGuB1kFXRfVyg5d87+Dg4DL6m2TLAub60ilj7A1Ec4odSAc8X95sHh7+ZRPCFo6Fnp7HfU/fBng/hi10CjCnWnJjsxvDNxWw0NfV6Rv5GgP3I3jGWXumdTD/3cbEOP2ZbOZp69yniG3FQ9z1jD7bnBu9Fc2tKGC2q+uAJOQHBDRiZX1x36o7fWBs7J9ownbtO+n0/qWkvW7UPIfc37WgT6ZGR++EOJyeQDSb9UB+DZ1G6DdLDzyS+b/kBCYGsYgJbSQHuThGKRcw5xdeQf8YdNHsc6ePXrlSYMBuSIAFTGAtQo+VuALo4BX83N190NWZWbynBjhOHsmNfFWLeL6v+ynsA58zDvvAC8j5PkbOcXCMg2PZFk3q8MjI7WAG/Dp9AwP7jdGBOOQkAvlFUB+irtm16I1Zw9YBcpGTGXYmk3kQIC/Cds55l+iMI3jqhjAuaoe+am2Jw5GT3Nbz3CkE12NavmzN5+erJW7046n/CH1RO/RVa8lBLozXk9uqykkGAyRXLWlLv5jyp4RFsG5vGVzpDLnIjTWgnRy2Rr+tDKvRc7Y8AyZq10jj8DqXdnIRNtFZb+t/ZRtXcDiVnzpqx8mPcDWxgARUqx0W1QB9MeUZiNrV4qP+Ehc+BpNgATsTX8ozYKL2NtFYAHc84fG7ndxUPr+AR/iQSns7uSUufAymwDOb2+NjK27lEFocm/EE2WpyIy/Hi66MWuMKJn8RvxIcj87IM5Vh9663ziW36kR0HNenXuxmfaD8JC7tfKbrhFr7LiZCrMjrzTeGx+PmkosrkNzW94ObzwocJ7A1HokLolY+AvkTiD/q1H0cN48c5EL8Crkttsa/AXQVDmutfyku0E7jShx49XqV3MFK8IryDhYVbj7Sj2P2eBxwcXoe8T8idsKKPRcnZw1b+slFTubwUwhktrfnAt7J++jwQtLZcm3sr9LQrjRzz6cfMv9aLvgmnAGvpoaGLxM4mAEaLV7iAzQ3oU0IvD5x9ix3yF2RAAuYAOO2f7PEFWCXZ4C9Pb2UsgDeVnFSpbFK7/IWu7TPTvBqzbGdCHOJQSxiEjt6IyZmxQyEJHv6xyQsYk//moVFsN2zP6fRImjfq7/n/wFDguUQFNEwugAAAABJRU5ErkJggg==');
  }

  div.callout-important.callout-style-default .callout-title {
    background-color: #f7dddc
  }

  div.callout-warning {
    border-left-color: #f0ad4e !important;
  }

  div.callout-warning .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAETklEQVRYCeVWW2gcVRg+58yaTUnizqbipZeX4uWhBEniBaoUX1Ioze52t7sRq6APio9V9MEaoWlVsFasRq0gltaAPuxms8lu0gcviE/FFOstVbSIxgcv6SU7EZqmdc7v9+9mJtNks51NTUH84ed889/PP+cmxP+d5FIbMJmNbpREu4WUkiTtCicKny0l1pIKmBzovF2S+hIJHX8iEu3hZJ5lNZGqyRrGSIQpq15AzF28jgpeY6yk6GVdrfFqdrD6Iw+QlB8g0YS2g7dyQmXM/IDhBhT0UCiRf59lfqmmDvzRt6kByV/m4JjtzuaujMUM2c5Z2d6JdKrRb3K2q6mA+oYVz8JnDdKPmmNthzkAk/lN63sYPgevrguc72aZX/L9C6x09GYyxBgCX4NlvyGUHOKELlm5rXeR1kchuChJt4SSwyddZRXgvwMGvYo4QSlk3/zkHD8UHxwVJA6zjZZqP8v8kK8OWLnIZtLyCAJagYC4rTGW/9Pqj92N/c+LUaAj27movwbi19tk/whRCIE7Q9vyI6yvRpftAKVTdUjOW40X3h5OXsKCdmFcx0xlLJoSuQngnrJe7Kcjm4OMq9FlC7CMmScQANuNvjfP3PjGXDBaUQmbp296S5L4DrpbrHN1T87ZVEZVCzg1FF0Ft+dKrlLukI+/c9ENo+TvlTDbYFvuKPtQ9+l052rXrgKoWkDAFnvh0wTOmYn8R5f4k/jN/fZiCM1tQx9jQQ4ANhqG4hiL0qIFTGViG9DKB7GYzgubnpofgYRwO+DFjh0Zin2m4b/97EDkXkc+f6xYAPX0KK2I/7fUQuwzuwo/L3AkcjugPNixC8cHf0FyPjWlItmLxWw4Ou9YsQCr5fijMGoD/zpdRy95HRysyXA74MWOnscpO4j2y3HAVisw85hX5+AFBRSHt4ShfLFkIMXTqyKFc46xdzQM6XbAi702a7sy04J0+feReMFKp5q9esYLCqAZYw/k14E/xcLLsFElaornTuJB0svMuJINy8xkIYuL+xPAlWRceH6+HX7THJ0djLUom46zREu7tTkxwmf/FdOZ/sh6Q8qvEAiHpm4PJ4a/doJe0gH1t+aHRgCzOvBvJedEK5OFE5jpm4AGP2a8Dxe3gGJ/pAutug9Gp6he92CsSsWBaEcxGx0FHytmIpuqGkOpldqNYQK8cSoXvd+xLxXADw0kf6UkJNFtdo5MOgaLjiQOQHcn+A6h5NuL2s0qsC2LOM75PcF3yr5STuBSAcGG+meA14K/CI21HcS4LBT6tv0QAh8Dr5l93AhZzG5ZJ4VxAqdZUEl9z7WJ4aN+svMvwHHL21UKTd1mqvChH7/Za5xzXBBKrUcB0TQ+Ulgkfbi/H/YT5EptrGzsEK7tR1B7ln9BBwckYfMiuSqklSznIuoIIOM42MQO+QnduCoFCI0bpkzjCjddHPN/F+2Yu+sd9bKNpVwHhbS3LluK/0zgfwD0xYI5dXuzlQAAAABJRU5ErkJggg==');
  }

  div.callout-warning.callout-style-default .callout-title {
    background-color: #fcefdc
  }

  div.callout-tip {
    border-left-color: #02b875 !important;
  }

  div.callout-tip .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADr0lEQVRYCe1XTWgTQRj9ZjZV8a9SPIkKgj8I1bMHsUWrqYLVg4Ue6v9BwZOxSYsIerFao7UiUryIqJcqgtpimhbBXoSCVxUFe9CTiogUrUp2Pt+3aUI2u5vdNh4dmMzOzHvvezuz8xNFM0mjnbXaNu1MvFWRXkXEyE6aYOYJpdW4IXuA4r0fo8qqSMDBU0v1HJUgVieAXxzCsdE/YJTdFcVIZQNMyhruOMJKXYFoLfIfIvVIMWdsrd+Rpd86ZmyzzjJmLStqRn0v8lzkb4rVIXvnpScOJuAn2ACC65FkPzEdEy4TPWRLJ2h7z4cArXzzaOdKlbOvKKX25Wl00jSnrwVxAg3o4dRxhO13RBSdNvH0xSARv3adTXbBdTf64IWO2vH0LT+cv4GR1DJt+DUItaQogeBX/chhbTBxEiZ6gftlDNXTrvT7co4ub5A6gp9HIcHvzTa46OS5fBeP87Qm0fQkr4FsYgVQ7Qg+ZayaDg9jhg1GkWj8RG6lkeSacrrHgDaxdoBiZPg+NXV/KifMuB6//JmYH4CntVEHy/keA6x4h4CU5oFy8GzrBS18cLJMXcljAKB6INjWsRcuZBWVaS3GDrqB7rdapVIeA+isQ57Eev9eCqzqOa81CY05VLd6SamW2wA2H3SiTbnbSxmzfp7WtKZkqy4mdyAlGx7ennghYf8voqp9cLSgKdqNfa6RdRsAAkPwRuJZNbpByn+RrJi1RXTwdi8RQF6ymDwGMAtZ6TVE+4uoKh+MYkcLsT0Hk8eAienbiGdjJHZTpmNjlbFJNKDVAp2fJlYju6IreQxQ08UJDNYdoLSl6AadO+fFuCQqVMB1NJwPm69T04Wv5WhfcWyfXQB+wXRs1pt+nCknRa0LVzSA/2B+a9+zQJadb7IyyV24YAxKp2Jqs3emZTuNnKxsah+uabKbMk7CbTgJx/zIgQYErIeTKRQ9yD9wxVof5YolPHqaWo7TD6tJlh7jQnK5z2n3+fGdggIOx2kaa2YI9QWarc5Ce1ipNWMKeSG4DysFF52KBmTNMmn5HqCFkwy34rDg05gDwgH3bBi+sgFhN/e8QvRn8kbamCOhgrZ9GJhFDgfcMHzFb6BAtjKpFhzTjwv1KCVuxHvCbsSiEz4CANnj84cwHdFXAbAOJ4LTSAawGWFn5tDhLMYz6nWeU2wJfIhmIJBefcd/A5FWQWGgrWzyORZ3Q6HuV+Jf0Bj+BTX69fm1zWgK7By1YTXchFDORywnfQ7GpzOo6S+qECrsx2ifVQAAAABJRU5ErkJggg==');
  }

  div.callout-tip.callout-style-default .callout-title {
    background-color: #ccf1e3
  }

  div.callout-caution {
    border-left-color: #fd7e14 !important;
  }

  div.callout-caution .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAACV0lEQVRYCdVWzWoUQRCuqp2ICBLJXgITZL1EfQDBW/bkzUMUD7klD+ATSHBEfAIfQO+iXsWDxJsHL96EHAwhgzlkg8nBg25XWb0zIb0zs9muYYWkoKeru+vn664fBqElyZNuyh167NXJ8Ut8McjbmEraKHkd7uAnAFku+VWdb3reSmRV8PKSLfZ0Gjn3a6Xlcq9YGb6tADjn+lUfTXtVmaZ1KwBIvFI11rRXlWlatwIAAv2asaa9mlB9wwygiDX26qaw1yYPzFXg2N1GgG0FMF8Oj+VIx7E/03lHx8UhvYyNZLN7BwSPgekXXLribw7w5/c8EF+DBK5idvDVYtEEwMeYefjjLAdEyQ3M9nfOkgnPTEkYU+sxMq0BxNR6jExrAI31H1rzvLEfRIdgcv1XEdj6QTQAS2wtstEALLG1yEZ3QhH6oDX7ExBSFEkFINXH98NTrme5IOaaA7kIfiu2L8A3qhH9zRbukdCqdsA98TdElyeMe5BI8Rs2xHRIsoTSSVFfCFCWGPn9XHb4cdobRIWABNf0add9jakDjQJpJ1bTXOJXnnRXHRf+dNL1ZV1MBRCXhMbaHqGI1JkKIL7+i8uffuP6wVQAzO7+qVEbF6NbS0LJureYcWXUUhH66nLR5rYmva+2tjRFtojkM2aD76HEGAD3tPtKM309FJg5j/K682ywcWJ3PASCcycH/22u+Bh7Aa0ehM2Fu4z0SAE81HF9RkB21c5bEn4Dzw+/qNOyXr3DCTQDMBOdhi4nAgiFDGCinIa2owCEChUwD8qzd03PG+qdW/4fDzjUMcE1ZpIAAAAASUVORK5CYII=');
  }

  div.callout-caution.callout-style-default .callout-title {
    background-color: #ffe5d0
  }

  </style>
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  <script src="index_files/libs/htmlwidgets-1.6.2/htmlwidgets.js"></script>
  <script src="index_files/libs/r2d3-render-0.1.0/r2d3-render.js"></script>
  <script src="index_files/libs/webcomponents-2.0.0/webcomponents.js"></script>
  <script src="index_files/libs/r2d3-binding-0.2.6/r2d3.js"></script>
  <script src="index_files/libs/d3v5-5.9.2/d3.min.js"></script>
  <script src="index_files/libs/d3-jetpack-2.0.9/d3-jetpack.js"></script>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" data-notes="Hello everyone, my name is Dillon Murphy, and I’m an undergrad student at Cal Poly in San Luis Obispo, California. Today, I am excited to present an overview of the youdrawitR package with my co-presenter Emily. This package serves as a tool for interactive data visualization in R." class="quarto-title-block center">
  <h1 class="title">Overview of the youdrawitR Package</h1>
  <p class="subtitle">Interactive Data Visualization in R</p>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Dillon Murphy, Cal Poly - San Luis Obispo, CA 
</div>
</div>
</div>

</section>
<section>
<section id="introduction" class="title-slide slide level1 center">
<h1>Introduction</h1>

</section>
<section id="google-summer-of-code-2023" class="slide level2" data-background-image="images/GSOCtimeline.png" data-background-size="100%">
<h2>Google Summer of Code 2023</h2>
<aside class="notes">
<p>Before diving into the package, I’d like to briefly touch upon my journey with Google Summer of Code this summer.</p>
<p>For those unfamiliar with Google Summer of Code, it is a global program that offers students stipends to write code for open source projects, and aims to bring student developers into the open source community. If you look at the timeline displayed on this slide, it provides a snapshot of how the program is structured.</p>
<p>I had the privilege of developing the youdrawitR package during the Google Summer of Code 2023, under the guidance of my mentors: Emily, Susan, and Heike,</p>
<p>It was a great experience and I highly recommend this opportunity for students passionate about coding and open-source contributions, especially for those who might consider themselves beginner programmers or developers. It’s a great program that taught me lots of practical skills and granted me a decent amount of money.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="overview-of-the-youdrawitr-package" class="slide level2">
<h2>Overview of the <code>youdrawitR</code> Package</h2>
<p><svg aria-hidden="true" role="img" viewbox="0 0 512 512" style="height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;"><path d="M64 64c0-17.7-14.3-32-32-32S0 46.3 0 64V400c0 44.2 35.8 80 80 80H480c17.7 0 32-14.3 32-32s-14.3-32-32-32H80c-8.8 0-16-7.2-16-16V64zm406.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L320 210.7l-57.4-57.4c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L240 221.3l57.4 57.4c12.5 12.5 32.8 12.5 45.3 0l128-128z"></path></svg>&nbsp;&nbsp;Interactive Data Visualization in R</p>
<p><svg aria-hidden="true" role="img" viewbox="0 0 640 512" style="height:1em;width:1.25em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;"><path d="M96 128a128 128 0 1 1 256 0A128 128 0 1 1 96 128zM0 482.3C0 383.8 79.8 304 178.3 304h91.4C368.2 304 448 383.8 448 482.3c0 16.4-13.3 29.7-29.7 29.7H29.7C13.3 512 0 498.7 0 482.3zM625 177L497 305c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L591 143c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"></path></svg>&nbsp;Engaging users with data</p>

<img src="images/drawr-example-1.gif" style="display: block; margin: auto;" class="r-stretch"><aside class="notes">
<p>Alright, now let’s get into the primary focus of the presentation, the <code>youdrawitR</code> package.</p>
<p>As the name suggests, the primary feature of this package is its interactive nature. <code>youdrawitR</code> presents a method for users to actively engage with data. Instead of merely observing static graphs, users can draw and make their own interpretations.</p>
<p>Take a look at the gif on the screen, you’ll see an example in action. The user begins by drawing a boundary for the confidence region and then sketches their guess for the line of best fit. After completion of the guess, the real confidence region and line of best fit is overlayed, which allows for a direct comparison. This hands-on approach encourages active participation in data analysis, and allows us to see how our intuitive perceptions align with actual data trends.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="background-for-measuring-trends" class="slide level2">
<h2>Background for Measuring Trends</h2>
<ul>
<li>Fitting Trends by Eye – maneuvering a string, black thread, or ruler.</li>
</ul>
<div class="columns">
<div class="column">
<ul>
<li><a href="https://www.nytimes.com/interactive/2015/05/28/upshot/you-draw-it-how-family-income-affects-childrens-college-chances.html">New York Times ‘You Draw It’ feature</a> (Aisch, Cox, and Quealy, 2015)</li>
<li><a href="https://jds-online.org/journal/JDS/article/1317/info">‘You Draw It’: Implementation of Visually Fitted Trends with <code>r2d3</code></a></li>
<li><a href="https://www.tandfonline.com/doi/abs/10.1080/10618600.2022.2140668?journalCode=ucgs20">Eye Fitting Straight Lines in the Modern Era</a></li>
</ul>
</div><div class="column">
<p><img data-src="images/nyt-caraccidents.png"></p>
</div>
</div>
</section>
<section id="motivations-behind-creating-the-package" class="slide level2">
<h2>Motivations Behind Creating the Package</h2>
<p>D3 is not intuitive for us R users <svg aria-hidden="true" role="img" viewbox="0 0 640 512" style="height:1em;width:1.25em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;"><path d="M384 96V320H64L64 96H384zM64 32C28.7 32 0 60.7 0 96V320c0 35.3 28.7 64 64 64H181.3l-10.7 32H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H352c17.7 0 32-14.3 32-32s-14.3-32-32-32H277.3l-10.7-32H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zm464 0c-26.5 0-48 21.5-48 48V432c0 26.5 21.5 48 48 48h64c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48H528zm16 64h32c8.8 0 16 7.2 16 16s-7.2 16-16 16H544c-8.8 0-16-7.2-16-16s7.2-16 16-16zm-16 80c0-8.8 7.2-16 16-16h32c8.8 0 16 7.2 16 16s-7.2 16-16 16H544c-8.8 0-16-7.2-16-16zm32 160a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"></path></svg> <svg aria-hidden="true" role="img" viewbox="0 0 576 512" style="height:1em;width:1.12em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;"><path d="M64 112c-8.8 0-16 7.2-16 16V384c0 8.8 7.2 16 16 16H512c8.8 0 16-7.2 16-16V128c0-8.8-7.2-16-16-16H64zM0 128C0 92.7 28.7 64 64 64H512c35.3 0 64 28.7 64 64V384c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V128zM176 320H400c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V336c0-8.8 7.2-16 16-16zm-72-72c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H120c-8.8 0-16-7.2-16-16V248zm16-96h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H120c-8.8 0-16-7.2-16-16V168c0-8.8 7.2-16 16-16zm64 96c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H200c-8.8 0-16-7.2-16-16V248zm16-96h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H200c-8.8 0-16-7.2-16-16V168c0-8.8 7.2-16 16-16zm64 96c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H280c-8.8 0-16-7.2-16-16V248zm16-96h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H280c-8.8 0-16-7.2-16-16V168c0-8.8 7.2-16 16-16zm64 96c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H360c-8.8 0-16-7.2-16-16V248zm16-96h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H360c-8.8 0-16-7.2-16-16V168c0-8.8 7.2-16 16-16zm64 96c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H440c-8.8 0-16-7.2-16-16V248zm16-96h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H440c-8.8 0-16-7.2-16-16V168c0-8.8 7.2-16 16-16z"></path></svg></p>

<img data-src="images/code-sketch.png" width="518" class="r-stretch quarto-figure-center"><p>Add additional functionality for broader use</p>
</section></section>
<section>
<section id="getting-started-with-youdrawitr" class="title-slide slide level1 center">
<h1>Getting Started with youdrawitR</h1>

</section>
<section id="using-youdrawitr" class="slide level2">
<h2>Using <code>youdrawitR</code></h2>
<ul>
<li><p>Install: <code>devtools::install_github("earobinson95/youdrawitR")</code></p></li>
<li><p>Load: <code>library(youdrawitR)</code></p></li>
<li><p>Data generation: <code>customDataGen()</code> and <code>linearDataGen()</code></p></li>
<li><p>Visualization: <code>drawr()</code></p>
<p><img data-src="images/youdrawit_flowchart.png"></p></li>
</ul>
<p>Package website:<a href="https://earobinson95.github.io/youdrawitR/" class="uri">https://earobinson95.github.io/youdrawitR/</a></p>
<aside class="notes">
<p>To get started, the installation process is pretty straightforward. You can install the package directly from GitHub using the devtools package. Once installed, simply load it like any other R package.</p>
<p>The package provides two functions for data generation and preparation: customDataGen() and linearDataGen(). For visualization, use the formatted data from these function and input them into the drawr() function, as seen in the flowchart.</p>
<p>If you’d like to explore more feel free to visit the package website listed here for comprehensive documentation and examples. We will also play around with the package in R later in this presentation, so I recommend keeping that website for then.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="data-generation-with-youdrawitr" class="slide level2">
<h2>Data Generation with <code>youdrawitR</code></h2>
<div class="columns">
<ul>
<li>Using <code>customDataGen</code> and <code>linearDataGen</code> for data preparation.</li>
</ul><div class="column" style="width:50%;">
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># Example of using customDataGen</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>custom_data <span class="ot">&lt;-</span> <span class="fu">customDataGen</span>(</span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="at">df =</span> mtcars,</span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="at">xvar =</span> <span class="st">"mpg"</span>,</span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="at">yvar =</span> <span class="st">"hp"</span>,</span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="at">regression_type =</span> <span class="st">"linear"</span>,</span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="at">conf_int =</span> <span class="cn">TRUE</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div><div class="column" style="width:50%;">
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># Example of using linearDataGen</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>linear_data <span class="ot">&lt;-</span> <span class="fu">linearDataGen</span>(</span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="at">N =</span> <span class="dv">20</span>,</span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="at">slope =</span> <span class="fl">1.5</span>,</span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="at">y_int =</span> <span class="dv">0</span>,</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="at">sigma =</span> <span class="dv">2</span>,</span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="at">x_min =</span> <span class="dv">0</span>,</span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="at">x_max =</span> <span class="dv">20</span>,</span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="at">conf_int =</span> <span class="cn">TRUE</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
<aside class="notes">
<p>Let’s briefly go over the functions associated with the data preparation process.</p>
<p>On the left, you can see the customDataGen function. This function allows you to take any existing dataset, like mtcars in this example and make them suitable for the drawr() function. Some of the parameter option include defining your x and y variables, specifying the type of regression, or deciding if you want to generate a 95% confidence interval.</p>
<p>On the right, we have the linearDataGen function. This function is designed to simulate linear data based on the parameters you provide, like the slope, y-intercept, and standard deviation. It generates the simulated data in a format suitable for the drawr() function.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>
<section id="visualization-with-youdrawitr" class="title-slide slide level1 center">
<h1>Visualization with youdrawitR</h1>

</section>
<section id="visualizing-with-drawr" class="slide level2">
<h2>Visualizing with <code>drawr</code></h2>
<div class="columns">
<div class="column" style="width:35%;">
<ul>
<li>Renders interactive plots</li>
<li>Users can draw predictions</li>
<li>Customization options</li>
</ul>
</div><div class="column" style="width:65%;">
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Example using previously generated custom_data</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="fu">drawr</span>(custom_data, </span>
<span id="cb3-3"><a href="#cb3-3"></a>      <span class="at">title =</span> <span class="st">"Horsepower vs Miles per Gallon"</span>, </span>
<span id="cb3-4"><a href="#cb3-4"></a>      <span class="at">subtitle =</span> <span class="st">"For mtcars dataset"</span>,</span>
<span id="cb3-5"><a href="#cb3-5"></a>      <span class="at">x_lab =</span> <span class="st">"Miles per Gallon"</span>,</span>
<span id="cb3-6"><a href="#cb3-6"></a>      <span class="at">y_lab =</span> <span class="st">"Horsepower"</span>,</span>
<span id="cb3-7"><a href="#cb3-7"></a>      <span class="at">conf_int =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-4ec1a7b0dd7b7a51fc24" style="width:960px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-4ec1a7b0dd7b7a51fc24">{"x":{"data":{"line_data":[{"data":"line_data","x":10.4,"y":232.2531,"coef":-8.8297,"int":324.0823,"lower_bound":201.8649,"upper_bound":262.6414,"_row":1},{"data":"line_data","x":10.4,"y":232.2531,"coef":-8.8297,"int":324.0823,"lower_bound":201.8649,"upper_bound":262.6414,"_row":2},{"data":"line_data","x":13.3,"y":206.6469,"coef":-8.8297,"int":324.0823,"lower_bound":182.5314,"upper_bound":230.7624,"_row":3},{"data":"line_data","x":14.3,"y":197.8172,"coef":-8.8297,"int":324.0823,"lower_bound":175.6459,"upper_bound":219.9884,"_row":4},{"data":"line_data","x":14.7,"y":194.2853,"coef":-8.8297,"int":324.0823,"lower_bound":172.8476,"upper_bound":215.7229,"_row":5},{"data":"line_data","x":15,"y":191.6363,"coef":-8.8297,"int":324.0823,"lower_bound":170.7299,"upper_bound":212.5428,"_row":6},{"data":"line_data","x":15.2,"y":189.8704,"coef":-8.8297,"int":324.0823,"lower_bound":169.3083,"upper_bound":210.4325,"_row":7},{"data":"line_data","x":15.2,"y":189.8704,"coef":-8.8297,"int":324.0823,"lower_bound":169.3083,"upper_bound":210.4325,"_row":8},{"data":"line_data","x":15.5,"y":187.2215,"coef":-8.8297,"int":324.0823,"lower_bound":167.1602,"upper_bound":207.2827,"_row":9},{"data":"line_data","x":15.8,"y":184.5726,"coef":-8.8297,"int":324.0823,"lower_bound":164.9921,"upper_bound":204.153,"_row":10},{"data":"line_data","x":16.4,"y":179.2747,"coef":-8.8297,"int":324.0823,"lower_bound":160.5894,"upper_bound":197.96,"_row":11},{"data":"line_data","x":17.3,"y":171.328,"coef":-8.8297,"int":324.0823,"lower_bound":153.7947,"upper_bound":188.8612,"_row":12},{"data":"line_data","x":17.8,"y":166.9131,"coef":-8.8297,"int":324.0823,"lower_bound":149.906,"upper_bound":183.9202,"_row":13},{"data":"line_data","x":18.1,"y":164.2642,"coef":-8.8297,"int":324.0823,"lower_bound":147.5293,"upper_bound":180.999,"_row":14},{"data":"line_data","x":18.7,"y":158.9663,"coef":-8.8297,"int":324.0823,"lower_bound":142.6708,"upper_bound":175.2618,"_row":15},{"data":"line_data","x":19.2,"y":154.5515,"coef":-8.8297,"int":324.0823,"lower_bound":138.5083,"upper_bound":170.5947,"_row":16},{"data":"line_data","x":19.2,"y":154.5515,"coef":-8.8297,"int":324.0823,"lower_bound":138.5083,"upper_bound":170.5947,"_row":17},{"data":"line_data","x":19.7,"y":150.1366,"coef":-8.8297,"int":324.0823,"lower_bound":134.2369,"upper_bound":166.0364,"_row":18},{"data":"line_data","x":21,"y":138.658,"coef":-8.8297,"int":324.0823,"lower_bound":122.6072,"upper_bound":154.7087,"_row":19},{"data":"line_data","x":21,"y":138.658,"coef":-8.8297,"int":324.0823,"lower_bound":122.6072,"upper_bound":154.7087,"_row":20},{"data":"line_data","x":21.4,"y":135.1261,"coef":-8.8297,"int":324.0823,"lower_bound":118.8788,"upper_bound":151.3734,"_row":21},{"data":"line_data","x":21.4,"y":135.1261,"coef":-8.8297,"int":324.0823,"lower_bound":118.8788,"upper_bound":151.3734,"_row":22},{"data":"line_data","x":21.5,"y":134.2431,"coef":-8.8297,"int":324.0823,"lower_bound":117.9361,"upper_bound":150.5501,"_row":23},{"data":"line_data","x":22.8,"y":122.7644,"coef":-8.8297,"int":324.0823,"lower_bound":105.3226,"upper_bound":140.2063,"_row":24},{"data":"line_data","x":22.8,"y":122.7644,"coef":-8.8297,"int":324.0823,"lower_bound":105.3226,"upper_bound":140.2063,"_row":25},{"data":"line_data","x":24.4,"y":108.6369,"coef":-8.8297,"int":324.0823,"lower_bound":89.027,"upper_bound":128.2468,"_row":26},{"data":"line_data","x":26,"y":94.5093,"coef":-8.8297,"int":324.0823,"lower_bound":72.1151,"upper_bound":116.9036,"_row":27},{"data":"line_data","x":27.3,"y":83.0307,"coef":-8.8297,"int":324.0823,"lower_bound":58.0608,"upper_bound":108.0005,"_row":28},{"data":"line_data","x":30.4,"y":55.6585,"coef":-8.8297,"int":324.0823,"lower_bound":23.8471,"upper_bound":87.4699,"_row":29},{"data":"line_data","x":30.4,"y":55.6585,"coef":-8.8297,"int":324.0823,"lower_bound":23.8471,"upper_bound":87.4699,"_row":30},{"data":"line_data","x":32.4,"y":37.999,"coef":-8.8297,"int":324.0823,"lower_bound":1.4538,"upper_bound":74.5443,"_row":31},{"data":"line_data","x":33.9,"y":24.7544,"coef":-8.8297,"int":324.0823,"lower_bound":-15.4426,"upper_bound":64.9514,"_row":32}],"point_data":[{"data":"point_data","x":10.4,"y":205,"_row":1},{"data":"point_data","x":10.4,"y":215,"_row":2},{"data":"point_data","x":13.3,"y":245,"_row":3},{"data":"point_data","x":14.3,"y":245,"_row":4},{"data":"point_data","x":14.7,"y":230,"_row":5},{"data":"point_data","x":15,"y":335,"_row":6},{"data":"point_data","x":15.2,"y":180,"_row":7},{"data":"point_data","x":15.2,"y":150,"_row":8},{"data":"point_data","x":15.5,"y":150,"_row":9},{"data":"point_data","x":15.8,"y":264,"_row":10},{"data":"point_data","x":16.4,"y":180,"_row":11},{"data":"point_data","x":17.3,"y":180,"_row":12},{"data":"point_data","x":17.8,"y":123,"_row":13},{"data":"point_data","x":18.1,"y":105,"_row":14},{"data":"point_data","x":18.7,"y":175,"_row":15},{"data":"point_data","x":19.2,"y":123,"_row":16},{"data":"point_data","x":19.2,"y":175,"_row":17},{"data":"point_data","x":19.7,"y":175,"_row":18},{"data":"point_data","x":21,"y":110,"_row":19},{"data":"point_data","x":21,"y":110,"_row":20},{"data":"point_data","x":21.4,"y":110,"_row":21},{"data":"point_data","x":21.4,"y":109,"_row":22},{"data":"point_data","x":21.5,"y":97,"_row":23},{"data":"point_data","x":22.8,"y":93,"_row":24},{"data":"point_data","x":22.8,"y":95,"_row":25},{"data":"point_data","x":24.4,"y":62,"_row":26},{"data":"point_data","x":26,"y":91,"_row":27},{"data":"point_data","x":27.3,"y":66,"_row":28},{"data":"point_data","x":30.4,"y":52,"_row":29},{"data":"point_data","x":30.4,"y":113,"_row":30},{"data":"point_data","x":32.4,"y":66,"_row":31},{"data":"point_data","x":33.9,"y":65,"_row":32}],"lower_bound":[{"x":10.4,"y":201.8649,"_row":1},{"x":10.4,"y":201.8649,"_row":2},{"x":13.3,"y":182.5314,"_row":3},{"x":14.3,"y":175.6459,"_row":4},{"x":14.7,"y":172.8476,"_row":5},{"x":15,"y":170.7299,"_row":6},{"x":15.2,"y":169.3083,"_row":7},{"x":15.2,"y":169.3083,"_row":8},{"x":15.5,"y":167.1602,"_row":9},{"x":15.8,"y":164.9921,"_row":10},{"x":16.4,"y":160.5894,"_row":11},{"x":17.3,"y":153.7947,"_row":12},{"x":17.8,"y":149.906,"_row":13},{"x":18.1,"y":147.5293,"_row":14},{"x":18.7,"y":142.6708,"_row":15},{"x":19.2,"y":138.5083,"_row":16},{"x":19.2,"y":138.5083,"_row":17},{"x":19.7,"y":134.2369,"_row":18},{"x":21,"y":122.6072,"_row":19},{"x":21,"y":122.6072,"_row":20},{"x":21.4,"y":118.8788,"_row":21},{"x":21.4,"y":118.8788,"_row":22},{"x":21.5,"y":117.9361,"_row":23},{"x":22.8,"y":105.3226,"_row":24},{"x":22.8,"y":105.3226,"_row":25},{"x":24.4,"y":89.027,"_row":26},{"x":26,"y":72.1151,"_row":27},{"x":27.3,"y":58.0608,"_row":28},{"x":30.4,"y":23.8471,"_row":29},{"x":30.4,"y":23.8471,"_row":30},{"x":32.4,"y":1.4538,"_row":31},{"x":33.9,"y":-15.4426,"_row":32}],"upper_bound":[{"x":10.4,"y":262.6414,"_row":1},{"x":10.4,"y":262.6414,"_row":2},{"x":13.3,"y":230.7624,"_row":3},{"x":14.3,"y":219.9884,"_row":4},{"x":14.7,"y":215.7229,"_row":5},{"x":15,"y":212.5428,"_row":6},{"x":15.2,"y":210.4325,"_row":7},{"x":15.2,"y":210.4325,"_row":8},{"x":15.5,"y":207.2827,"_row":9},{"x":15.8,"y":204.153,"_row":10},{"x":16.4,"y":197.96,"_row":11},{"x":17.3,"y":188.8612,"_row":12},{"x":17.8,"y":183.9202,"_row":13},{"x":18.1,"y":180.999,"_row":14},{"x":18.7,"y":175.2618,"_row":15},{"x":19.2,"y":170.5947,"_row":16},{"x":19.2,"y":170.5947,"_row":17},{"x":19.7,"y":166.0364,"_row":18},{"x":21,"y":154.7087,"_row":19},{"x":21,"y":154.7087,"_row":20},{"x":21.4,"y":151.3734,"_row":21},{"x":21.4,"y":151.3734,"_row":22},{"x":21.5,"y":150.5501,"_row":23},{"x":22.8,"y":140.2063,"_row":24},{"x":22.8,"y":140.2063,"_row":25},{"x":24.4,"y":128.2468,"_row":26},{"x":26,"y":116.9036,"_row":27},{"x":27.3,"y":108.0005,"_row":28},{"x":30.4,"y":87.4699,"_row":29},{"x":30.4,"y":87.4699,"_row":30},{"x":32.4,"y":74.5443,"_row":31},{"x":33.9,"y":64.9514,"_row":32}]},"type":"json","container":"svg","options":{"draw_start":10.4,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[10.4,33.9],"x_by":0,"x_lab":"Miles per Gallon","y_range":[9.242155260478363,350.5122783209296],"y_lab":"Horsepower","subtitle":"For mtcars dataset","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Horsepower vs Miles per Gallon","conf_int":true},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  C:/Users/Dillon Murphy/AppData/Local/R/win-library/4.2/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"y\", -20)\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", -3)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</div>
</div>
<aside class="notes">
<p>Now we can briefly discuss the drawr function, which creates the interactive plots. This function allows users to actively engage with the generated data by drawing their predictions and is equipped with several customization features.</p>
<p>Take a look at the sample code presented. We’re visualizing the data we generate in the previous slide with the customDataGen function.</p>
<p>I encourage anyone who is following along on their own device to try playing around with the output on their computer. If you find any latency with the rendering of the output, which seems to be an issue with quarto slides, a quick page refresh should fix the issue.</p>
<p>One feature worth highlighting is the New Line button. This button allows the user to add suplementary lines to their plot which can be used in a variety of ways, for instance drawing the upper and lower bounds of a 95% confidence interval like the gif in the beginning. For this example, we can see that a confidence interval has been generated with the parameter conf_int = TRUE.</p>
<p>In the next slide we will go over a few more example of using the drawr and customDataGen functions with different customizations and regressions.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="section" class="slide level2" data-auto-animate="true">
<h2 data-id="quarto-animate-title"></h2>
<div class="columns">
<div class="column" style="max-width: min-content; white-space: nowrap;">
<p><strong>More Examples:</strong></p>
</div><div class="column" style="flex: 1; text-align: left;">
<p><strong>Logistic Regression</strong></p>
</div>
</div>
<div class="panel-tabset">
<ul id="tabset-1" class="panel-tabset-tabby"><li><a data-tabby-default="" href="#tabset-1-1">Code</a></li><li><a href="#tabset-1-2">Plot</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1">
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy" data-id="quarto-animate-code"><code class="sourceCode r hljs"><span id="cb4-1" class="hljs-ln-code"><a href="#cb4-1"></a><span class="co"># Generating data with logistic regression</span></span>
<span id="cb4-2" class="hljs-ln-code"><a href="#cb4-2"></a><span class="co"># For this example, we'll need a binary response variable. </span></span>
<span id="cb4-3" class="hljs-ln-code"><a href="#cb4-3"></a><span class="co"># Let's create a binary variable based on horsepower.</span></span>
<span id="cb4-4" class="hljs-ln-code"><a href="#cb4-4"></a>mtcars<span class="sc">$</span>high_hp <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(mtcars<span class="sc">$</span>hp <span class="sc">&gt;</span> <span class="dv">120</span>, <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb4-5" class="hljs-ln-code"><a href="#cb4-5"></a></span>
<span id="cb4-6" class="hljs-ln-code"><a href="#cb4-6"></a>logistic_data <span class="ot">&lt;-</span> <span class="fu">customDataGen</span>(</span>
<span id="cb4-7" class="hljs-ln-code"><a href="#cb4-7"></a>  <span class="at">df =</span> mtcars,</span>
<span id="cb4-8" class="hljs-ln-code"><a href="#cb4-8"></a>  <span class="at">xvar =</span> <span class="st">"mpg"</span>,</span>
<span id="cb4-9" class="hljs-ln-code"><a href="#cb4-9"></a>  <span class="at">yvar =</span> <span class="st">"high_hp"</span>,</span>
<span id="cb4-10" class="hljs-ln-code"><a href="#cb4-10"></a>  <span class="at">regression_type =</span> <span class="st">"logistic"</span></span>
<span id="cb4-11" class="hljs-ln-code"><a href="#cb4-11"></a>)</span>
<span id="cb4-12" class="hljs-ln-code"><a href="#cb4-12"></a></span>
<span id="cb4-13" class="hljs-ln-code"><a href="#cb4-13"></a><span class="fu">drawr</span>(logistic_data, </span>
<span id="cb4-14" class="hljs-ln-code"><a href="#cb4-14"></a>      <span class="at">title =</span> <span class="st">"Probability High Horsepower vs MPG (Logistic)"</span>, </span>
<span id="cb4-15" class="hljs-ln-code"><a href="#cb4-15"></a>      <span class="at">subtitle =</span> <span class="st">"For mtcars dataset"</span>,</span>
<span id="cb4-16" class="hljs-ln-code"><a href="#cb4-16"></a>      <span class="at">x_lab =</span> <span class="st">"Miles per Gallon"</span>,</span>
<span id="cb4-17" class="hljs-ln-code"><a href="#cb4-17"></a>      <span class="at">y_lab =</span> <span class="st">"High Horsepower (1 = Yes, 0 = No)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-1-2">
<div class="cell">
<div class="cell-output-display">
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-54391fde17ee7963b67d" style="width:960px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-54391fde17ee7963b67d">{"x":{"data":{"line_data":[{"data":"line_data","x":10.4,"y":1,"coef":-1.5055,"int":"29.6782361392675","_row":1},{"data":"line_data","x":10.4,"y":1,"coef":-1.5055,"int":"29.6782361392675","_row":2},{"data":"line_data","x":13.3,"y":0.9999,"coef":-1.5055,"int":"29.6782361392675","_row":3},{"data":"line_data","x":14.3,"y":0.9997,"coef":-1.5055,"int":"29.6782361392675","_row":4},{"data":"line_data","x":14.7,"y":0.9995,"coef":-1.5055,"int":"29.6782361392675","_row":5},{"data":"line_data","x":15,"y":0.9992,"coef":-1.5055,"int":"29.6782361392675","_row":6},{"data":"line_data","x":15.2,"y":0.9989,"coef":-1.5055,"int":"29.6782361392675","_row":7},{"data":"line_data","x":15.2,"y":0.9989,"coef":-1.5055,"int":"29.6782361392675","_row":8},{"data":"line_data","x":15.5,"y":0.9982,"coef":-1.5055,"int":"29.6782361392675","_row":9},{"data":"line_data","x":15.8,"y":0.9972,"coef":-1.5055,"int":"29.6782361392675","_row":10},{"data":"line_data","x":16.4,"y":0.9932,"coef":-1.5055,"int":"29.6782361392675","_row":11},{"data":"line_data","x":17.3,"y":0.9742,"coef":-1.5055,"int":"29.6782361392675","_row":12},{"data":"line_data","x":17.8,"y":0.9468,"coef":-1.5055,"int":"29.6782361392675","_row":13},{"data":"line_data","x":18.1,"y":0.9189,"coef":-1.5055,"int":"29.6782361392675","_row":14},{"data":"line_data","x":18.7,"y":0.8212,"coef":-1.5055,"int":"29.6782361392675","_row":15},{"data":"line_data","x":19.2,"y":0.6839,"coef":-1.5055,"int":"29.6782361392675","_row":16},{"data":"line_data","x":19.2,"y":0.6839,"coef":-1.5055,"int":"29.6782361392675","_row":17},{"data":"line_data","x":19.7,"y":0.5048,"coef":-1.5055,"int":"29.6782361392675","_row":18},{"data":"line_data","x":21,"y":0.1259,"coef":-1.5055,"int":"29.6782361392675","_row":19},{"data":"line_data","x":21,"y":0.1259,"coef":-1.5055,"int":"29.6782361392675","_row":20},{"data":"line_data","x":21.4,"y":0.0731,"coef":-1.5055,"int":"29.6782361392675","_row":21},{"data":"line_data","x":21.4,"y":0.0731,"coef":-1.5055,"int":"29.6782361392675","_row":22},{"data":"line_data","x":21.5,"y":0.0635,"coef":-1.5055,"int":"29.6782361392675","_row":23},{"data":"line_data","x":22.8,"y":0.0095,"coef":-1.5055,"int":"29.6782361392675","_row":24},{"data":"line_data","x":22.8,"y":0.0095,"coef":-1.5055,"int":"29.6782361392675","_row":25},{"data":"line_data","x":24.4,"y":0.0009,"coef":-1.5055,"int":"29.6782361392675","_row":26},{"data":"line_data","x":26,"y":0.0001,"coef":-1.5055,"int":"29.6782361392675","_row":27},{"data":"line_data","x":27.3,"y":0,"coef":-1.5055,"int":"29.6782361392675","_row":28},{"data":"line_data","x":30.4,"y":1.0284e-07,"coef":-1.5055,"int":"29.6782361392675","_row":29},{"data":"line_data","x":30.4,"y":1.0284e-07,"coef":-1.5055,"int":"29.6782361392675","_row":30},{"data":"line_data","x":32.4,"y":5.0638e-09,"coef":-1.5055,"int":"29.6782361392675","_row":31},{"data":"line_data","x":33.9,"y":5.293e-10,"coef":-1.5055,"int":"29.6782361392675","_row":32}],"point_data":[{"data":"point_data","x":10.4,"y":1,"_row":1},{"data":"point_data","x":10.4,"y":1,"_row":2},{"data":"point_data","x":13.3,"y":1,"_row":3},{"data":"point_data","x":14.3,"y":1,"_row":4},{"data":"point_data","x":14.7,"y":1,"_row":5},{"data":"point_data","x":15,"y":1,"_row":6},{"data":"point_data","x":15.2,"y":1,"_row":7},{"data":"point_data","x":15.2,"y":1,"_row":8},{"data":"point_data","x":15.5,"y":1,"_row":9},{"data":"point_data","x":15.8,"y":1,"_row":10},{"data":"point_data","x":16.4,"y":1,"_row":11},{"data":"point_data","x":17.3,"y":1,"_row":12},{"data":"point_data","x":17.8,"y":1,"_row":13},{"data":"point_data","x":18.1,"y":0,"_row":14},{"data":"point_data","x":18.7,"y":1,"_row":15},{"data":"point_data","x":19.2,"y":1,"_row":16},{"data":"point_data","x":19.2,"y":1,"_row":17},{"data":"point_data","x":19.7,"y":1,"_row":18},{"data":"point_data","x":21,"y":0,"_row":19},{"data":"point_data","x":21,"y":0,"_row":20},{"data":"point_data","x":21.4,"y":0,"_row":21},{"data":"point_data","x":21.4,"y":0,"_row":22},{"data":"point_data","x":21.5,"y":0,"_row":23},{"data":"point_data","x":22.8,"y":0,"_row":24},{"data":"point_data","x":22.8,"y":0,"_row":25},{"data":"point_data","x":24.4,"y":0,"_row":26},{"data":"point_data","x":26,"y":0,"_row":27},{"data":"point_data","x":27.3,"y":0,"_row":28},{"data":"point_data","x":30.4,"y":0,"_row":29},{"data":"point_data","x":30.4,"y":0,"_row":30},{"data":"point_data","x":32.4,"y":0,"_row":31},{"data":"point_data","x":33.9,"y":0,"_row":32}]},"type":"json","container":"svg","options":{"draw_start":10.4,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[10.4,33.9],"x_by":0,"x_lab":"Miles per Gallon","y_range":[-0.05,1.05],"y_lab":"High Horsepower (1 = Yes, 0 = No)","subtitle":"For mtcars dataset","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Probability High Horsepower vs MPG (Logistic)","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  C:/Users/Dillon Murphy/AppData/Local/R/win-library/4.2/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"y\", -20)\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", -3)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</div>
</div>
</div>
<aside class="notes">
<p>Here is our first additional example, we’re using a logistic regression. Logistic regression is great for when you have a binary response variable. For our purpose, we’ve created a binary variable high_hp which signifies whether a car has high horsepower based on a threshold of 120.</p>
<p>In the code, we prepare this data using the customDataGen function and then visualize it with drawr. What’s showcased here is the probability of a car having high horsepower versus its miles per gallon.</p>
<p>Now let’s look at the plot. Drawing a logistic regression may prove to be less intuitive than a normal linear regression, and I again encourage to try for yourself.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="section-1" class="slide level2" data-auto-animate="true">
<h2 data-id="quarto-animate-title"></h2>
<div class="columns">
<div class="column" style="max-width: min-content; white-space: nowrap;">
<p><strong>More Examples:</strong></p>
</div><div class="column" style="flex: 1; text-align: left; white-space: nowrap;">
<p><strong>Polynomial Regression &amp; Customized Plot</strong></p>
</div>
</div>
<div class="panel-tabset">
<ul id="tabset-2" class="panel-tabset-tabby"><li><a data-tabby-default="" href="#tabset-2-1">Code</a></li><li><a href="#tabset-2-2">Plot</a></li></ul>
<div class="tab-content">
<div id="tabset-2-1">
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource r number-lines code-with-copy" data-id="quarto-animate-code"><code class="sourceCode r hljs"><span id="cb5-1" class="hljs-ln-code"><a href="#cb5-1"></a><span class="co"># Generating data with polynomial regression of degree 2</span></span>
<span id="cb5-2" class="hljs-ln-code"><a href="#cb5-2"></a>poly_data <span class="ot">&lt;-</span> <span class="fu">customDataGen</span>(</span>
<span id="cb5-3" class="hljs-ln-code"><a href="#cb5-3"></a>  <span class="at">df =</span> mtcars,</span>
<span id="cb5-4" class="hljs-ln-code"><a href="#cb5-4"></a>  <span class="at">xvar =</span> <span class="st">"mpg"</span>,</span>
<span id="cb5-5" class="hljs-ln-code"><a href="#cb5-5"></a>  <span class="at">yvar =</span> <span class="st">"hp"</span>,</span>
<span id="cb5-6" class="hljs-ln-code"><a href="#cb5-6"></a>  <span class="at">regression_type =</span> <span class="st">"polynomial"</span>,</span>
<span id="cb5-7" class="hljs-ln-code"><a href="#cb5-7"></a>  <span class="at">degree =</span> <span class="dv">2</span></span>
<span id="cb5-8" class="hljs-ln-code"><a href="#cb5-8"></a>)</span>
<span id="cb5-9" class="hljs-ln-code"><a href="#cb5-9"></a></span>
<span id="cb5-10" class="hljs-ln-code"><a href="#cb5-10"></a><span class="co"># Customized drawr output</span></span>
<span id="cb5-11" class="hljs-ln-code"><a href="#cb5-11"></a><span class="fu">drawr</span>(poly_data, </span>
<span id="cb5-12" class="hljs-ln-code"><a href="#cb5-12"></a>      <span class="at">title =</span> <span class="st">"Horsepower vs Miles per Gallon (Polynomial)"</span>, </span>
<span id="cb5-13" class="hljs-ln-code"><a href="#cb5-13"></a>      <span class="at">subtitle =</span> <span class="st">"For mtcars dataset"</span>,</span>
<span id="cb5-14" class="hljs-ln-code"><a href="#cb5-14"></a>      <span class="at">x_lab =</span> <span class="st">"Miles per Gallon"</span>,</span>
<span id="cb5-15" class="hljs-ln-code"><a href="#cb5-15"></a>      <span class="at">y_lab =</span> <span class="st">"Horsepower"</span>,</span>
<span id="cb5-16" class="hljs-ln-code"><a href="#cb5-16"></a>      <span class="at">drawn_line_color =</span> <span class="st">"red"</span>,</span>
<span id="cb5-17" class="hljs-ln-code"><a href="#cb5-17"></a>      <span class="at">true_line_color =</span> <span class="st">"rgba(0,255,0,.8)"</span>,</span>
<span id="cb5-18" class="hljs-ln-code"><a href="#cb5-18"></a>      <span class="at">draw_region_color =</span> <span class="st">"#FFFFFF"</span>,</span>
<span id="cb5-19" class="hljs-ln-code"><a href="#cb5-19"></a>      <span class="at">show_tooltip =</span> <span class="cn">TRUE</span>,</span>
<span id="cb5-20" class="hljs-ln-code"><a href="#cb5-20"></a>      <span class="at">aspect_ratio =</span> <span class="fl">1.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-2-2">
<div class="cell">
<div class="cell-output-display">
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-03ce885611f3e750ca74" style="width:960px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-03ce885611f3e750ca74">{"x":{"data":{"line_data":[{"data":"line_data","x":10.4,"y":263.7824,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":1},{"data":"line_data","x":10.4,"y":263.7824,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":2},{"data":"line_data","x":13.3,"y":218.7662,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":3},{"data":"line_data","x":14.3,"y":204.5305,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":4},{"data":"line_data","x":14.7,"y":199.021,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":5},{"data":"line_data","x":15,"y":194.9582,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":6},{"data":"line_data","x":15.2,"y":192.2827,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":7},{"data":"line_data","x":15.2,"y":192.2827,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":8},{"data":"line_data","x":15.5,"y":188.3189,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":9},{"data":"line_data","x":15.8,"y":184.4145,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":10},{"data":"line_data","x":16.4,"y":176.7839,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":11},{"data":"line_data","x":17.3,"y":165.7836,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":12},{"data":"line_data","x":17.8,"y":159.9034,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":13},{"data":"line_data","x":18.1,"y":156.4545,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":14},{"data":"line_data","x":18.7,"y":149.7348,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":15},{"data":"line_data","x":19.2,"y":144.3166,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":16},{"data":"line_data","x":19.2,"y":144.3166,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":17},{"data":"line_data","x":19.7,"y":139.0634,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":18},{"data":"line_data","x":21,"y":126.1773,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":19},{"data":"line_data","x":21,"y":126.1773,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":20},{"data":"line_data","x":21.4,"y":122.4368,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":21},{"data":"line_data","x":21.4,"y":122.4368,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":22},{"data":"line_data","x":21.5,"y":121.5182,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":23},{"data":"line_data","x":22.8,"y":110.1767,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":24},{"data":"line_data","x":22.8,"y":110.1767,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":25},{"data":"line_data","x":24.4,"y":97.7492,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":26},{"data":"line_data","x":26,"y":87.0115,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":27},{"data":"line_data","x":27.3,"y":79.5313,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":28},{"data":"line_data","x":30.4,"y":66.1956,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":29},{"data":"line_data","x":30.4,"y":66.1956,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":30},{"data":"line_data","x":32.4,"y":60.9582,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":31},{"data":"line_data","x":33.9,"y":58.7628,"coef":"-23.3445176264287, 0.330028840792629","int":470.8695,"_row":32}],"point_data":[{"data":"point_data","x":10.4,"y":205,"_row":1},{"data":"point_data","x":10.4,"y":215,"_row":2},{"data":"point_data","x":13.3,"y":245,"_row":3},{"data":"point_data","x":14.3,"y":245,"_row":4},{"data":"point_data","x":14.7,"y":230,"_row":5},{"data":"point_data","x":15,"y":335,"_row":6},{"data":"point_data","x":15.2,"y":180,"_row":7},{"data":"point_data","x":15.2,"y":150,"_row":8},{"data":"point_data","x":15.5,"y":150,"_row":9},{"data":"point_data","x":15.8,"y":264,"_row":10},{"data":"point_data","x":16.4,"y":180,"_row":11},{"data":"point_data","x":17.3,"y":180,"_row":12},{"data":"point_data","x":17.8,"y":123,"_row":13},{"data":"point_data","x":18.1,"y":105,"_row":14},{"data":"point_data","x":18.7,"y":175,"_row":15},{"data":"point_data","x":19.2,"y":123,"_row":16},{"data":"point_data","x":19.2,"y":175,"_row":17},{"data":"point_data","x":19.7,"y":175,"_row":18},{"data":"point_data","x":21,"y":110,"_row":19},{"data":"point_data","x":21,"y":110,"_row":20},{"data":"point_data","x":21.4,"y":110,"_row":21},{"data":"point_data","x":21.4,"y":109,"_row":22},{"data":"point_data","x":21.5,"y":97,"_row":23},{"data":"point_data","x":22.8,"y":93,"_row":24},{"data":"point_data","x":22.8,"y":95,"_row":25},{"data":"point_data","x":24.4,"y":62,"_row":26},{"data":"point_data","x":26,"y":91,"_row":27},{"data":"point_data","x":27.3,"y":66,"_row":28},{"data":"point_data","x":30.4,"y":52,"_row":29},{"data":"point_data","x":30.4,"y":113,"_row":30},{"data":"point_data","x":32.4,"y":66,"_row":31},{"data":"point_data","x":33.9,"y":65,"_row":32}]},"type":"json","container":"svg","options":{"draw_start":10.4,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1.5,"pin_start":true,"x_range":[10.4,33.9],"x_by":0,"x_lab":"Miles per Gallon","y_range":[37.85,349.15],"y_lab":"Horsepower","subtitle":"For mtcars dataset","line_style":null,"drawn_line_color":"red","data_line_color":"rgba(0,255,0,.8)","draw_region_color":null,"show_finished":true,"show_tooltip":true,"title":"Horsepower vs Miles per Gallon (Polynomial)","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  C:/Users/Dillon Murphy/AppData/Local/R/win-library/4.2/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"y\", -20)\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", -3)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</div>
</div>
</div>
<aside class="notes">
<p>Now, for the next example we will be using a polynomial regression. Specifically, we’re looking at a polynomial of degree 2. Polynomial regressions allow us to capture more intricate relationships that aren’t strictly linear, and can also be a little harder to predict compared to linear regression.</p>
<p>In our code, we utilize the customDataGen function for data prep, specifying the regression type as “polynomial” and degree as 2.</p>
<p>Additionally, look at the code for the drawr function. This time, we’ve also added a bit more flair to our plot with customized colors and display settings.</p>
<p>Taking a look at the plot you can see the progress region has been removed, a tooltip is now shown, the drawn line is now red,the plot is now wider, and the true line is now green. Such customizations can aid in data interpretation or simply make your visualization more engaging.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="section-2" class="slide level2" data-auto-animate="true">
<h2 data-id="quarto-animate-title"></h2>
<div class="columns">
<div class="column" style="max-width: min-content; white-space: nowrap;">
<p><strong>More Examples:</strong></p>
</div><div class="column" style="flex: 1; text-align: left;">
<p><strong>Loess Regression</strong></p>
</div>
</div>
<div class="panel-tabset">
<ul id="tabset-3" class="panel-tabset-tabby"><li><a data-tabby-default="" href="#tabset-3-1">Code</a></li><li><a href="#tabset-3-2">Plot</a></li></ul>
<div class="tab-content">
<div id="tabset-3-1">
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource r number-lines code-with-copy" data-id="quarto-animate-code"><code class="sourceCode r hljs"><span id="cb6-1" class="hljs-ln-code"><a href="#cb6-1"></a><span class="co"># Generating data with loess regression</span></span>
<span id="cb6-2" class="hljs-ln-code"><a href="#cb6-2"></a>loess_data <span class="ot">&lt;-</span> <span class="fu">customDataGen</span>(</span>
<span id="cb6-3" class="hljs-ln-code"><a href="#cb6-3"></a>  <span class="at">df =</span> mtcars,</span>
<span id="cb6-4" class="hljs-ln-code"><a href="#cb6-4"></a>  <span class="at">xvar =</span> <span class="st">"mpg"</span>,</span>
<span id="cb6-5" class="hljs-ln-code"><a href="#cb6-5"></a>  <span class="at">yvar =</span> <span class="st">"hp"</span>,</span>
<span id="cb6-6" class="hljs-ln-code"><a href="#cb6-6"></a>  <span class="at">regression_type =</span> <span class="st">"loess"</span>,</span>
<span id="cb6-7" class="hljs-ln-code"><a href="#cb6-7"></a>  <span class="at">span =</span> <span class="fl">0.75</span></span>
<span id="cb6-8" class="hljs-ln-code"><a href="#cb6-8"></a>)</span>
<span id="cb6-9" class="hljs-ln-code"><a href="#cb6-9"></a></span>
<span id="cb6-10" class="hljs-ln-code"><a href="#cb6-10"></a><span class="fu">drawr</span>(loess_data, </span>
<span id="cb6-11" class="hljs-ln-code"><a href="#cb6-11"></a>      <span class="at">title =</span> <span class="st">"Horsepower vs Miles per Gallon (Loess)"</span>, </span>
<span id="cb6-12" class="hljs-ln-code"><a href="#cb6-12"></a>      <span class="at">subtitle =</span> <span class="st">"For mtcars dataset"</span>,</span>
<span id="cb6-13" class="hljs-ln-code"><a href="#cb6-13"></a>      <span class="at">x_lab =</span> <span class="st">"Miles per Gallon"</span>,</span>
<span id="cb6-14" class="hljs-ln-code"><a href="#cb6-14"></a>      <span class="at">y_lab =</span> <span class="st">"Horsepower"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-3-2">
<div class="cell">
<div class="cell-output-display">
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-6afd2ddd08d911de9c70" style="width:960px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-6afd2ddd08d911de9c70">{"x":{"data":{"line_data":[{"data":"line_data","x":10.4,"y":243.6002,"_row":1},{"data":"line_data","x":10.4,"y":243.6002,"_row":2},{"data":"line_data","x":13.3,"y":220.3397,"_row":3},{"data":"line_data","x":14.3,"y":212.5516,"_row":4},{"data":"line_data","x":14.7,"y":208.5382,"_row":5},{"data":"line_data","x":15,"y":206.1758,"_row":6},{"data":"line_data","x":15.2,"y":205.1799,"_row":7},{"data":"line_data","x":15.2,"y":205.1799,"_row":8},{"data":"line_data","x":15.5,"y":202.3346,"_row":9},{"data":"line_data","x":15.8,"y":197.9126,"_row":10},{"data":"line_data","x":16.4,"y":189.2798,"_row":11},{"data":"line_data","x":17.3,"y":175.9116,"_row":12},{"data":"line_data","x":17.8,"y":167.7223,"_row":13},{"data":"line_data","x":18.1,"y":162.3972,"_row":14},{"data":"line_data","x":18.7,"y":151.4243,"_row":15},{"data":"line_data","x":19.2,"y":143.0206,"_row":16},{"data":"line_data","x":19.2,"y":143.0206,"_row":17},{"data":"line_data","x":19.7,"y":135.4179,"_row":18},{"data":"line_data","x":21,"y":116.8839,"_row":19},{"data":"line_data","x":21,"y":116.8839,"_row":20},{"data":"line_data","x":21.4,"y":112.5786,"_row":21},{"data":"line_data","x":21.4,"y":112.5786,"_row":22},{"data":"line_data","x":21.5,"y":111.3644,"_row":23},{"data":"line_data","x":22.8,"y":99.3932,"_row":24},{"data":"line_data","x":22.8,"y":99.3932,"_row":25},{"data":"line_data","x":24.4,"y":89.541,"_row":26},{"data":"line_data","x":26,"y":87.3822,"_row":27},{"data":"line_data","x":27.3,"y":84.1384,"_row":28},{"data":"line_data","x":30.4,"y":72.3717,"_row":29},{"data":"line_data","x":30.4,"y":72.3717,"_row":30},{"data":"line_data","x":32.4,"y":65.3948,"_row":31},{"data":"line_data","x":33.9,"y":60.3689,"_row":32}],"point_data":[{"data":"point_data","x":10.4,"y":205,"_row":1},{"data":"point_data","x":10.4,"y":215,"_row":2},{"data":"point_data","x":13.3,"y":245,"_row":3},{"data":"point_data","x":14.3,"y":245,"_row":4},{"data":"point_data","x":14.7,"y":230,"_row":5},{"data":"point_data","x":15,"y":335,"_row":6},{"data":"point_data","x":15.2,"y":180,"_row":7},{"data":"point_data","x":15.2,"y":150,"_row":8},{"data":"point_data","x":15.5,"y":150,"_row":9},{"data":"point_data","x":15.8,"y":264,"_row":10},{"data":"point_data","x":16.4,"y":180,"_row":11},{"data":"point_data","x":17.3,"y":180,"_row":12},{"data":"point_data","x":17.8,"y":123,"_row":13},{"data":"point_data","x":18.1,"y":105,"_row":14},{"data":"point_data","x":18.7,"y":175,"_row":15},{"data":"point_data","x":19.2,"y":123,"_row":16},{"data":"point_data","x":19.2,"y":175,"_row":17},{"data":"point_data","x":19.7,"y":175,"_row":18},{"data":"point_data","x":21,"y":110,"_row":19},{"data":"point_data","x":21,"y":110,"_row":20},{"data":"point_data","x":21.4,"y":110,"_row":21},{"data":"point_data","x":21.4,"y":109,"_row":22},{"data":"point_data","x":21.5,"y":97,"_row":23},{"data":"point_data","x":22.8,"y":93,"_row":24},{"data":"point_data","x":22.8,"y":95,"_row":25},{"data":"point_data","x":24.4,"y":62,"_row":26},{"data":"point_data","x":26,"y":91,"_row":27},{"data":"point_data","x":27.3,"y":66,"_row":28},{"data":"point_data","x":30.4,"y":52,"_row":29},{"data":"point_data","x":30.4,"y":113,"_row":30},{"data":"point_data","x":32.4,"y":66,"_row":31},{"data":"point_data","x":33.9,"y":65,"_row":32}]},"type":"json","container":"svg","options":{"draw_start":10.4,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[10.4,33.9],"x_by":0,"x_lab":"Miles per Gallon","y_range":[37.85,349.15],"y_lab":"Horsepower","subtitle":"For mtcars dataset","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Horsepower vs Miles per Gallon (Loess)","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  C:/Users/Dillon Murphy/AppData/Local/R/win-library/4.2/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"y\", -20)\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", -3)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</div>
</div>
</div>
<aside class="notes">
<p>Our last example includes the final regression type currently offered in the youdrawitR package, loess regression. Loess regression is great for capturing local patterns in data.</p>
<p>In our code, we generate the data using the customDataGen function and define the regression type as “loess”. We’ve also chosen a span parameter which dictates the degree of smoothing.</p>
<p>The resulting drawr visualization presents horsepower against miles per gallon. Lets take a look at the plot and try for ourselves. As Emily has described it to me before, drawing loess regression is like giving a child a crayon and asking them to draw a line between the points on a graph.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="your-turn-1" class="slide level2">
<h2>Your Turn 1</h2>
<!-- Let user install and use package -->
<p>Using the documentation <code>help(drawr)</code>, change xxxx</p>
<!-- Questions about what worked -->
</section>
<section id="embedding-youdrawitr-into-html" class="slide level2">
<h2>Embedding <code>youdrawitR</code> into HTML</h2>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li>Quarto</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># Render with quarto/Rmarkdown  </span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="do">## For quarto: use quarto &gt;= 1.3.450 or knitr &lt;1.43</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="fu">drawr</span>(linear_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-0f9d38e8f7bd91cd9f02" style="width:960px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-0f9d38e8f7bd91cd9f02">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":3.3285,"_row":1},{"data":"point_data","x":1.0526,"y":4.2261,"_row":2},{"data":"point_data","x":2.1053,"y":3.3715,"_row":3},{"data":"point_data","x":3.1579,"y":4.088,"_row":4},{"data":"point_data","x":4.2105,"y":3.0799,"_row":5},{"data":"point_data","x":5.2632,"y":6.7362,"_row":6},{"data":"point_data","x":6.3158,"y":9.0776,"_row":7},{"data":"point_data","x":7.3684,"y":12.2956,"_row":8},{"data":"point_data","x":8.4211,"y":11.9893,"_row":9},{"data":"point_data","x":9.4737,"y":12.0611,"_row":10},{"data":"point_data","x":10.5263,"y":16.3225,"_row":11},{"data":"point_data","x":11.5789,"y":18.6583,"_row":12},{"data":"point_data","x":12.6316,"y":18.3673,"_row":13},{"data":"point_data","x":13.6842,"y":21.7049,"_row":14},{"data":"point_data","x":14.7368,"y":23.3866,"_row":15},{"data":"point_data","x":15.7895,"y":21.3593,"_row":16},{"data":"point_data","x":16.8421,"y":24.2835,"_row":17},{"data":"point_data","x":17.8947,"y":30.059,"_row":18},{"data":"point_data","x":18.9474,"y":28.6226,"_row":19},{"data":"point_data","x":20,"y":28.3464,"_row":20}],"line_data":[{"data":"line_data","x":0,"y":0.4477,"coef":1.4621,"int":0.4477,"lower_bound":-1.2156,"upper_bound":2.1109,"_row":1},{"data":"line_data","x":1.0526,"y":1.9867,"coef":1.4621,"int":0.4477,"lower_bound":0.4493,"upper_bound":3.524,"_row":2},{"data":"line_data","x":2.1053,"y":3.5257,"coef":1.4621,"int":0.4477,"lower_bound":2.1097,"upper_bound":4.9416,"_row":3},{"data":"line_data","x":3.1579,"y":5.0647,"coef":1.4621,"int":0.4477,"lower_bound":3.7642,"upper_bound":6.3652,"_row":4},{"data":"line_data","x":4.2105,"y":6.6037,"coef":1.4621,"int":0.4477,"lower_bound":5.411,"upper_bound":7.7964,"_row":5},{"data":"line_data","x":5.2632,"y":8.1427,"coef":1.4621,"int":0.4477,"lower_bound":7.0479,"upper_bound":9.2374,"_row":6},{"data":"line_data","x":6.3158,"y":9.6817,"coef":1.4621,"int":0.4477,"lower_bound":8.6721,"upper_bound":10.6913,"_row":7},{"data":"line_data","x":7.3684,"y":11.2207,"coef":1.4621,"int":0.4477,"lower_bound":10.28,"upper_bound":12.1614,"_row":8},{"data":"line_data","x":8.4211,"y":12.7597,"coef":1.4621,"int":0.4477,"lower_bound":11.8679,"upper_bound":13.6515,"_row":9},{"data":"line_data","x":9.4737,"y":14.2987,"coef":1.4621,"int":0.4477,"lower_bound":13.4324,"upper_bound":15.165,"_row":10},{"data":"line_data","x":10.5263,"y":15.8377,"coef":1.4621,"int":0.4477,"lower_bound":14.9714,"upper_bound":16.704,"_row":11},{"data":"line_data","x":11.5789,"y":17.3767,"coef":1.4621,"int":0.4477,"lower_bound":16.485,"upper_bound":18.2685,"_row":12},{"data":"line_data","x":12.6316,"y":18.9157,"coef":1.4621,"int":0.4477,"lower_bound":17.9751,"upper_bound":19.8564,"_row":13},{"data":"line_data","x":13.6842,"y":20.4547,"coef":1.4621,"int":0.4477,"lower_bound":19.4452,"upper_bound":21.4643,"_row":14},{"data":"line_data","x":14.7368,"y":21.9938,"coef":1.4621,"int":0.4477,"lower_bound":20.899,"upper_bound":23.0885,"_row":15},{"data":"line_data","x":15.7895,"y":23.5328,"coef":1.4621,"int":0.4477,"lower_bound":22.3401,"upper_bound":24.7254,"_row":16},{"data":"line_data","x":16.8421,"y":25.0718,"coef":1.4621,"int":0.4477,"lower_bound":23.7713,"upper_bound":26.3723,"_row":17},{"data":"line_data","x":17.8947,"y":26.6108,"coef":1.4621,"int":0.4477,"lower_bound":25.1948,"upper_bound":28.0267,"_row":18},{"data":"line_data","x":18.9474,"y":28.1498,"coef":1.4621,"int":0.4477,"lower_bound":26.6125,"upper_bound":29.6871,"_row":19},{"data":"line_data","x":20,"y":29.6888,"coef":1.4621,"int":0.4477,"lower_bound":28.0255,"upper_bound":31.3521,"_row":20}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"","y_range":[-1.032914691822129,31.53954045643075],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  C:/Users/Dillon Murphy/AppData/Local/R/win-library/4.2/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"y\", -20)\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", -3)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</div><div class="column" style="width:50%;">
<ul>
<li>Direct Save as HTML</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># Save into an html</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="fu">drawr</span>(linear_data, </span>
<span id="cb8-3"><a href="#cb8-3"></a>      <span class="at">save_html_file_path =</span> <span class="st">"myViz.html"</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="do">## Embedded HTML below</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<iframe src="images/myViz.html" width="100%" height="400px">
</iframe>
</div>
</div>
<aside class="notes">
<p>An advantage of using youdrawitR is the ease with which you can embed and share the interactive outputs.</p>
<p>On the left, you’ll see the integration using either Quarto or RMarkdown. Simply create your plot using the drawr function and then render it within your document. Just a heads-up for compatibility: If you’re using Quarto, ensure you’re using the latest version.</p>
<p>On the right, provided is a straightforward method to save your visualization directly as an HTML file. This comes in handy if you’re looking to quickly archive your visualization or share it as a standalone file. With the drawr function, just specify your desired file path, and it will handle the rest for you. Specifying just the name of the file will save it to your current working directory. Once saved, this visualization can be opened and interacted with in any standard web browser.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>
<section id="using-youdrawitr-with-shiny" class="title-slide slide level1 center">
<h1>Using <code>youdrawitR</code> with Shiny</h1>

</section>
<section id="integrating-into-shiny" class="slide level2">
<h2>Integrating Into Shiny</h2>
<ul>
<li>Displaying Visualizations</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># ui </span></span>
<span id="cb9-2"><a href="#cb9-2"></a>r2d3<span class="sc">::</span><span class="fu">d3Output</span>(<span class="st">"shinydrawr"</span>, <span class="at">height =</span> <span class="st">"500px"</span>, <span class="at">width =</span> <span class="st">"800px"</span>)</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co"># server</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>output<span class="sc">$</span>shinydrawr <span class="ot">&lt;-</span> r2d3<span class="sc">::</span><span class="fu">renderD3</span>({ <span class="fu">drawr</span>(data, <span class="at">hide_buttons =</span> T )})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="columns">
<div class="column">
<ul>
<li>Retrieving Drawn Data</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># Drawn data is sent to shiny from the </span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"># js file upon completion of the original line.</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co"># Fetch the original line data</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>jsonlite<span class="sc">::</span><span class="fu">fromJSON</span>(input<span class="sc">$</span>completedLineData)</span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="co"># Fetch any additional lines drawn</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>jsonlite<span class="sc">::</span><span class="fu">fromJSON</span>(input<span class="sc">$</span>newLineData)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div><div class="column">
<ul>
<li>Adding Button Functionality</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Send message to js file</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>session<span class="sc">$</span><span class="fu">sendCustomMessage</span>(<span class="st">"resetAction"</span>, <span class="st">"true"</span>)</span>
<span id="cb11-3"><a href="#cb11-3"></a>session<span class="sc">$</span><span class="fu">sendCustomMessage</span>(<span class="st">"newLine"</span>, <span class="st">"true"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
<aside class="notes">
<p>Another advantage of the youdrawitR package is how it can be easily integrated into Shiny, one of R’s most powerful tools for creating interactive web application’s.</p>
<p>To display the interactive visualizations in a Shiny application, there are just a few steps. In the user interface, the function r2d3::d3Output creates a placeholder for our interactive plot and then on the server side, we use r2d3::renderD3 to generate and render the interactive plot using our drawr function and whatever user provided data we have. Here, the hide_buttons parameter ensures a cleaner user experience by removing additional buttons from the visualization. These buttons can be recreated as shiny buttons in the shiny app with the sendCustomMessage function which gives the application a consistent and cleaner look, however hiding and recreating the buttons is optional.</p>
<p>Lastly, an important feature of the youdrawitR package is the ability to save the user drawn data for future use. In R it can be simply downloaded with the download data button at any point, but in Shiny the data is sent to Shiny upon completion of the line, where it can then be captured and saved.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="can-you-draw-it-shiny-app" class="slide level2">
<h2>‘Can You Draw It?’ Shiny App</h2>
<ul>
<li>Real time interaction with plot:
<ul>
<li>Change data sources: Input, Simulate, or Use R Dataset</li>
<li>Drawing, saving users drawn lines, and resetting functionalities</li>
<li>Customization: Color changes, tooltips, confidence intervals.</li>
</ul></li>
<li>Access:
<ul>
<li><a href="https://dillonmurphy.shinyapps.io/youdrawit/">Open in Browser</a> or run locally</li>
</ul></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>shiny<span class="sc">::</span><span class="fu">runApp</span>(<span class="fu">system.file</span>(<span class="st">"shinyapp/youdrawit"</span>, <span class="at">package =</span> <span class="st">"youdrawitR"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<aside class="notes">
<p>Now, let me introduce the ‘Can You Draw It?’ Shiny App, which is integrated within the youdrawitR package and provides an easy way to use all of the packages features. This app provides real-time interaction with youdrawitR plots.</p>
<p>There are multiple ways to access the app. If you’re looking to check it out on your browser, simply click on the ‘Open in Browser’ link. If you have the youdrawitR package installed, you can run it locally using the R command provided. The shiny app is also embedded into the next slide, so you can use it by following along on the presentation as we continue. I will go over all of the buttons, features, and customization options on the next slide using the embedded shiny app and I encourage you all to use it alongside me and provide any suggestions you may have for improvements.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="try-for-yourself" class="slide level2">
<h2>Try For Yourself</h2>
<iframe width="100%" height="100%" src="https://dillonmurphy.shinyapps.io/youdrawit/">
</iframe>
<aside class="notes">

<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="drawing-cat-competition" class="slide level2">
<h2>Drawing Cat Competition</h2>
</section></section>
<section>
<section id="importance-uses-of-youdrawitr" class="title-slide slide level1 center">
<h1>Importance &amp; Uses of <code>youdrawitR</code></h1>

</section>
<section id="potential-applications" class="slide level2">
<h2>Potential Applications</h2>
<ul>
<li>Engaging educational tool.</li>
<li>Personal data visualization projects.</li>
<li>Encouraging active participation in data interpretation.</li>
<li>Testing graphics for perception.</li>
</ul>
</section>
<section id="future-directions-for-youdrawitr" class="slide level2">
<h2>Future Directions for <code>youdrawitR</code></h2>
<ul>
<li>Continuous development.</li>
<li>Potential enhancements based on feedback.</li>
<li>Expansion of features and functionalities.</li>
</ul>
<div class="footer footer-default">

</div>
</section></section>
    </div>
  </div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="index_files/libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="index_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="index_files/libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="index_files/libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="index_files/libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="index_files/libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="index_files/libs/revealjs/plugin/notes/notes.js"></script>
  <script src="index_files/libs/revealjs/plugin/search/search.js"></script>
  <script src="index_files/libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="index_files/libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'smaller': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    
    <script>
      // htmlwidgets need to know to resize themselves when slides are shown/hidden.
      // Fire the "slideenter" event (handled by htmlwidgets.js) when the current
      // slide changes (different for each slide format).
      (function () {
        // dispatch for htmlwidgets
        function fireSlideEnter() {
          const event = window.document.createEvent("Event");
          event.initEvent("slideenter", true, true);
          window.document.dispatchEvent(event);
        }

        function fireSlideChanged(previousSlide, currentSlide) {
          fireSlideEnter();

          // dispatch for shiny
          if (window.jQuery) {
            if (previousSlide) {
              window.jQuery(previousSlide).trigger("hidden");
            }
            if (currentSlide) {
              window.jQuery(currentSlide).trigger("shown");
            }
          }
        }

        // hookup for slidy
        if (window.w3c_slidy) {
          window.w3c_slidy.add_observer(function (slide_num) {
            // slide_num starts at position 1
            fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);
          });
        }

      })();
    </script>

    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
      tabsets.forEach(function(tabset) {
        const tabby = new Tabby('#' + tabset.id);
      });
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button', {
        text: function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
      });
      clipboard.on('success', function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      });
      function tippyHover(el, contentFn) {
        const config = {
          allowHTML: true,
          content: contentFn,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.closest('section.slide') || el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start'
        };
          config['offset'] = [0,0];
          config['maxWidth'] = 700;
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          return note.innerHTML;
        });
      }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    

</body></html>